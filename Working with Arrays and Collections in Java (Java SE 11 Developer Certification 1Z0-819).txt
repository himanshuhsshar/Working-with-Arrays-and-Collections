Course Overview
Course Overview
Do you want to understand Java collections and the Java array data types better? Are you looking to study and pass the Java Developer certification exam? If so, then you have found the right course to help you with those goals. Arrays and collections are a foundational type to any language, and Java is no exception. Hello, everyone. My name is Dan Bunker, and welcome to my course on arrays, collections, and generics in Java. With a solid understanding of collections, you can pick the right data structure for your coding needs and solutions, understand the performance implications of each of the different collection types, and prepare to study and pass the collections portion of the Java Developer certification. By the end of this course, you'll be able to instantiate and use most of the common Java collection types. You'll also be more comfortable looking at and analyzing code snippets that use arrays, collections, and generics. To get the most out of this course, you should follow the Java Developer certification course path that Pluralsight has set up. This path will help you learn the proper Java concepts in the correct order, as well as help you pass the examination. Get ready to learn and to practice some code samples on your own and to internalize the Java concepts discussed in this course. With that, let's go ahead and get started.

Collection Fundamentals
Introduction
Collections and data structures are used all of the time in coding. This course is going to teach you a lot about the collection classes that Java provides as part of its core language offering. This course, however, is slightly different than other Pluralsight courses. This course is focused on helping you pass the collections portion of the Java Developer certification. There's a lot to go over. We need to know the basics first, so this part of the course will cover the foundational aspects of collections.

Java Arrays and Collections Primer
Java provides a lot of data structures and collection classes out of the box. To pass the arrays and collection portion of your Java SE certification, you'll need to focus on three areas. First, you will need to have a strong understanding of the primitive Java array. This is probably the most basic data structure that Java provides, and this will be the main focus coming up in the next part of this course. Second, you will need to understand the four main types of collection API classes, mainly lists, queues, sets, and maps, how they differ in Java's basic implementation of them. Finally, the collections and arrays tend to work easier when you set them up with generic typing and interface handles so your code can handle change better over time and allow for a variety of data types to be used with them. The collections API is quite extensive and large in Java, but don't worry. We'll break the concepts down into manageable chunks. Before going into each of these areas in depth, let's take a moment to quickly define exactly what a collection is.

What Is a Collection?
Since this course is all about collections, let's quickly cover what a collection is. If you're new to programming, you definitely will want to understand a collection because they are used all of the time. First, all a collection is is a group of elements that typically have some sort of relationship to each other. A group of animals or the letters of a word are examples of a collection. Next, the elements in your collection need some sort of way to be indexed so that you have a way to recall a specific element in the collection. This is generally done by a numbered position, how it's added, or by a key. If it's by number, you could get the third element in the list, if it's by position, you get the element by first or last, and if it's by key, you could find an animal with a key name of, say, lion or tiger. The four main types of collections are lists, sets, queues, and maps. Lists place elements in the collection by a numbered position, sets add elements by uniqueness, queues add elements by how they arrive, and maps reference elements by key name. Lists, arrays, sets, and queues are often printed out and conceptually represented as a sequential group of elements separated by a comma. This is an example of the English alphabet in list format. Maps are typically represented as a list of key‑value pairs. This example of mathematical constants has the key name first, followed by the value, so pi maps to 3.14, and so on. Next, let's talk about the difference between lists, sets, queues, and maps and why you would use one over the other.

Lists, Sets, Queues, and Maps
Lists, sets, queues, and maps are all considered collections, but they do have some differences and can be used to solve different data needs. The conceptual list is simply a collection of elements. The basic Java array data type is a type of list. It's indexed starting at 0, can allow for duplicate elements, and as it grows, the performance starts to slow down. Finding elements at the end of the list takes more time when the list is extremely large. Sets are almost the same as list. They are 0 index based and have the same performance considerations, depending on the implementation. The biggest difference is that every element in the set has to be unique. No duplicate elements are allowed in sets. Queues are like lists as well, but they are ordered by how elements are placed into the queue. These are sometimes referred to as FIFO, FIFO, or first in, first out. Performance and duplicates are the same as list. Maps overall are different than sets, lists, and queues, because each element in a map is paired with a key. Sometimes the key is a natural key, and sometimes you can use a hash code or a synthetic key. As maps get large, the performance of accessing items stays the same because items are found by key, rather than traversing the entire group of elements like a list would. Values in a map can't have the same key, so keys need to be unique. However, the value that a key maps to can be duplicated if you want. The Java Collection API has taken these basic concepts and created various implementations of these data structures. We'll quickly cover Java's take on this coming up next.

Java Collections API Overview
Java provides a well thought‑out hierarchy based around the four conceptual collections. Lists, sets, and queues extend from a common interface called collection. Maps, however, are fundamentally different. Java provides a hierarchy, starting with the map interface, for those type of collections. From there, Java provides concrete implementations of each collection type, ArrayList, vector, HashSet, and so on. This is just a subset of all the implementations that Java provides. Since there are a lot of concrete implementations, you can make it easier to learn and answer questions about them if you understand the main differences between list, queue, set, and map, and which classes are associated with them.

Collection Overview Cheat Sheets
There's a lot to know about the Java collection classes and hierarchy for the exam. I put together a couple of cheat sheets that you can access on my GitHub website. The URL is github.com/Dlbunker/Ps‑Collections‑1Z0‑819 I'm going to really briefly go over them here, but I suggest going out to the GitHub readmes and printing them out and possibly even creating flashcards to help you study the different characteristics and attributes of each collection type. First, you're going to want to have a solid grasp of the different core collection types we've covered so far. Understanding whether duplicates are allowed or if the elements in the collection type are ordered or not will help you build a solid foundation. Next, you will want to understand some specifics of the following classes that implement the core collection type. We will be going into more detail on many of these classes later in the course, but this is a quick, easy guide you can reference as you prepare for the exam. You should understand the parent interface for each Java type and whether the collection allows for null values and so on. Understanding these collection concepts and paradigms will also help you answer any questions that you might get where the exam asks what kind of collection would be appropriate to solve a certain problem?

Summary
That's it for our quick overview of what this part of the exam will be about and what the rest of this course is going to focus on. The big takeaways are understanding what a collection is. It's simply a structure that can hold related elements together and provide ways of accessing those elements. Know the difference between lists, sets, queues, and maps, and understand what specific Java collection classes implement which type of interface and understand their characteristics and attributes. Coming up next, we're going to get started with the most basic data collection structure Java provides, the array.

Working with Arrays
Introduction
In this part of the course, we're going to be working with the Java primitive array data type. This type of array has ties back to previous languages like C and C++ and has been a standard construct in many programming languages for many years. You'll get plenty of practice with declaring, implementing, traversing, and using arrays in this section of the course. While it's easy to code and become familiar with Java syntax in an IDE like IntelliJ, keep in mind that in the exam you won't have a compiler or IDE available. They will often ask questions like, is this valid Java code, or what happens when this code is run? Make sure that you're comfortable with all of the concepts presented here by following the code flow on paper and analyzing given code. Let's get started. First up, we'll take a look at the basic Java primitive array.

Java Primitive Arrays
In Java, arrays are data types, and they are declared much like any other data type in the programming language. Here's a basic Java array declaration. You begin by specifying the type of the array. In this example, the type is an array of int, or integer, numbers. Next, you need to follow the type with square brackets. This is the syntax for an array in Java. The next part is the variable name that you want to name the array or have it be known as. I've chosen the name ids here. You can generally call your array anything you'd like. The final part of an array declaration is the instantiation piece. Here we are creating a new int array and setting the default size of the array to 10. This creates an empty array with 10 possible spots available in it. All primitive arrays have to be instantiated with a size, or they have to be instantiated with specific elements defined. This array declaration is setting values in each array slot, rather than creating an empty array of a particular size. All arrays begin counting at 0. They're known as zero indexed. So 54 is at the zeroth position, 22 is at the first, 37 at the second, and so on. This array has a total of five elements in it. The Java compiler has gotten very smart over the years. You can now declare arrays like this that omit the redundant, int, and square brackets. The compiler knows what type you want based off of the declaration. This form of array declaration is known as an anonymous array.

Demo: Arrays in Action
For code examples and demos in this course, I'm going to be using the IntelliJ IDE. This is the Community edition, and you can find it and install it for free at jetbrains.com. If you want to use another IDE that you are familiar with, feel free to use that. I'm going to go ahead and create a new project. This is going to be a Java project, so I'm going to leave that selected, and for the project SDK, you want to use a Java version of 11 or greater for this course. So I'm just going to leave 12 selected and click Next, click Next again. For the project name, I'm going to call it java‑collections. For the project location, pick somewhere on your computer that you're happy with and click Finish. IntelliJ now has created an empty project for you, so I'm going to open up the java‑collections, and it has a src folder. This is where all of our sample code will go. I'm going to right‑click on that and create a new package, New, Java package. The name I'm going to just set as com,pluralsight. We now have a basic project and a place to test out code. I'm going to start by creating a main class that we can use at the root of the package that we'll begin to put our array code in. So I'm going to right‑click on com.pluralsight and say New, Java Class, and make sure Class is selected, and I'm going to give it a name of ArrayMain. This is just a basic main class in Java, and to make it runnable, we need to add the public static void main method, like this. This allows me to run code as a Java program. As a quick side note, that the incoming args param is an array of type string, so you can see that we've already encountered an array in our code without even doing anything. Let's go ahead and declare our ids array that we were just looking at. I'm also going to then print it out using the System.out.println, which looks like this. This array declaration is slightly different than what we saw previously. What do you think will print out if we were to run this code? The Java compiler is smart enough to warn us that the array might not be initialized. In this case, this code does not compile. If I hover over this error, you can see the error in the IntelliJ helper, but if you were to look at this code on the test, you would need to understand that by just realizing that the array had not been initialized. So let's go ahead and initialize the int array properly. Now that I save that, you can see that there are no errors according to IntelliJ. What do you think will happen now if you print this out? Well, let's go ahead and run this. We can right‑click and say, Run ArrayMain. You can see here in the output that it prints out a bunch of cryptic characters. This is the address space of the array in memory. To access each element, you have to index it like this. By specifying the square brackets in the index position, you can then access that element at that position. And if you remember, all arrays begin counting at 0, not 1, so in this case, what do you think this will print out now? Well, we can rerun this again, and now it prints out 0. You may be wondering where 0 came from, because we didn't initialize the element slots to anything yet. Since an int is a primitive data type in Java , all int elements have to be initialized to something. They can't be null. Java chose 0 as the default value, so let's see what happens if you have an array of strings like this. I've declared a string array called instruments of size 3, and I print out the very first element at slot 0. If I rerun this, it printed out null. So any time an array is initialized with an object type like a string, Java defaults the element slot to null. Instead of creating an empty array, let's change the array declaration to actually contain values. So now that we've given the instrument array three instrument string names, what do you think will print out now? If you said guitar, you're correct, because that is the string element in the zeroth position in the array that we've declared. As a quick side note on array syntax, arrays can be declared in a variety of ways. Here are some examples. You can generally put the square brackets anywhere you want to near the variable name. You can also declare an array with multiple variable names like this. Just be careful where you declare the square brackets if you're going to do this. You should do it at the beginning; otherwise, you might end up with an array and a couple of ints. As you've seen, Java treats primitive and objects differently when used with arrays. We'll take a look at how those values get allocated next.

Array Value Allocation
In the previous demo, we saw some interesting results of int arrays versus string arrays. Let's take a look at what Java is doing with these arrays under the covers. When you declare a primitive array like an int array, Java's actually allocating the primitive values right then and there. That looks like this. Each slot is initialized to the default primitive value. For int, that would be 0. The index position begins at 0. For the string array, Java allocates the values by reference. Java creates the index slots for the elements, but each index references an object in the Java memory heap. That's why when we first created a string array without declaring values, Java printed out null because there wasn't any object it was referencing yet. It truly was null. Make sure you know and understand the difference between how Java handles primitive arrays and object‑based arrays. This is known as referencing, and you may see code samples trying to test your knowledge on how values are initially allocated.

Demo: Accessing and Iterating Arrays
You've seen how to declare and create an array in Java. Next, you need to be able to iterate and access elements in the array. I'm back in IntelliJ, and these are the arrays that we've previously set up. The first thing that you may want to know when working with an array is how big is it? Every array has a length attribute on it. To print out the size of the instruments array, you can simply do this. If we run this code, it should print out 3 because we have 3 instruments stored in there. We can quickly do that, and you'll see that 3 is at the bottom of our output stack. Knowing the size or length of the array is important because that helps you iterate through all of the elements. Here's a for loop to iterate through the ids array. You'll notice it uses the length attribute to know when to terminate the loop. Now that we have a loop, we can do one of two things, we can access each element, or we can assign a value to each element. You'll notice that the ids array was never initialized, so we can do that now in the for loop. This code simply squares each value of i as it iterates through the loop and assigns it to that slot in the array. The assignment is done by the equals sign, and the array slot is chosen by indexing between the square brackets with the i variable. We can then access each element in the array by using the same indexing of the array, like this. Now when you run this, you can see each array slot printed out after it is assigned. So I'm just going to go over here and rerun my class really quick. You'll notice that we have a lot of output starting at 0, going all the way down to 81. A quick note about the for loop and the array. Note how we are using the less‑than sign. This properly ends the array without going out of bounds. What do you think would happen if we were to use less‑than or equal? Running that way throws an out of bounds exception because there aren't that many slots available in the array. You can test that out by adding that, saving the class, and running it. We did get to 81, but since we went out of bounds after that, we get the ArrayIndexOutOfBoundsException. When you take an exam, watch for small differences like this in code examples. They might show the less‑than or equals when it should only be less‑than. So I'm going to remove that equals so we can have running code. There are other loops that you can use with arrays. You can use the newer for loop variation to iterate through an array. That loop will look like this. This loop takes each element in the array and assigns it to the instrument variable. The disadvantage to this type of for loop is you can't assign values to the array while looping, but the advantage is, you don't have to worry about going out of bounds by messing up your iterator. Just for fun, we'll finish this demo by running the code. You can see that we did get our instruments printed out using that for loop style. Next up, we'll take a look at how to sort the elements in an array.

Demo: Sorting Arrays
The Java array data type is pretty limited in convenience methods that they offer. There's the index accessor and the length attribute. To do anything beyond that, we'll need some help from some outside helper classes that Java provides. The name of that helper class is simply called Arrays, and it's part of the java.util package. To use it, you'll first need to import it, so I'm going to add a line to my imports like this. Imports happen at the top of the class, and you can see that our arrays lives in the java.util package. Most IDEs could also import this for you if you choose to go that route. Now that we can use the Arrays class in our code, you may have a need to sort the elements in your array. And this array's helper can do that by using the sort method on it, and that would look like this. Scroll back to the bottom of my code, and I'm using Arrays.sort. Sort is a static method on Arrays, so you don't have to instantiate arrays to use it, and we can pass in the instruments into the sort method, and it will take care of the rest. Really quickly, I'm going to use IntelliJ just to inspect what the sort method offers an array. You can do that by doing Ctrl + space right after the dot, and you'll see that there's a sort method for all of the Java primitive types. That's because sorting each of those primitive types may behave differently. If it's a number, it's sourced numerically. And if it's streamed data like the instruments, it will sort that alphabetically. So to test that out, we need to print out the array that we just sorted. If you remember, we can't just print out the array because Java shows the memory address. So we can use the Arrays class to help us. Arrays contains another static method called toString. And as you might guess, the toString method will print out the array in a comma‑delimited list. So go ahead and rerun our code, and you can see in the output here that the Array.sort did work, and the elements are now reordered in alphabetical order, starting with bass and ending with guitar. It's important to know how to sort an array because if you want to search an array with predictable results, sorting helps with that. We'll take a look at search coming up next.

Demo: Searching Arrays
In the last demo, we utilized the arrays class to help sort our array. We'll be using that class again to help search our array. Let's start off by defining a new int array of the Fibonacci sequence, but not in sorted order. It'll look like this. Normally, the Fibonacci sequence should be 0, 1, 1, 2, 3, 5, 8, and 13. I changed up their order so we can understand how it affects searching arrays. I can use the arrays class to search for a specific element in the Fibonacci sequence like this. I'm using the binarySearch static method on arrays, and if I look at the arrays offerings there, you'll see that the binarySearch method defines overloaded options for each primitive type in Java. Again, searching for information is going to be specific for each data type. As you can imagine, searching through numbers is a little different than searching through strings. You don't need to know what a binary search is for the test, but quickly, what it does is, it cuts the elements in half, does a value comparison, and then picks that half and splits it in half again, comparing until it finds the element. BinarySearch is an efficient way of searching data, but it requires that the data needs to be sorted. So let's see what happens when we run the binarySearch for the number 3. Go ahead and run the code. Java is telling me that the number 3 is in the ‑7 position. That clearly can't be right, so what's happening here? Well, binarySearch only really works well, like I said, if the elements are sorted. Since these numbers aren't sorted, we get unreliable results. So we first need to sort, and then we can search. By adding Arrays.sort(fibArray) before we searched, it should help clear up our problem. Simply can rerun the code now. This time it says that the value 3 is in the 4th index position. If we were to reprint the fibArray after we sorted it, you can see that the 3rd value is in the 4th position, 0, 1, 1, 3. For the exam, here are the search rules that will help you pass. If the element is found in the sorted array, the result will be the index that element is in the array. If the element is not found in the sorted array, the results will be a negative number. If the array is not sorted or in correct order, the result will be random and unreliable, just like we saw in our example. Keep this in mind as you see questions related to searching and sorting on the test, especially when working with arrays. If they aren't sorted, they are trying to trick you.

Understanding Array Comparison
Let's take a minute and talk about comparing an array with another array. There are four ways that you can do array comparisons in Java. The first is using the array object equals method. This essentially tells you if the arrays are the same object on the memory heap. This method is rarely useful with arrays and should probably be ignored for the most part, especially when coding in real projects. Next is the helper equals method in the arrays class. This returns true if both arrays contain the same number of elements, and all the elements in each index are at the same value. The compare method is similar to equals, but it compares each array to determine if one is bigger or smaller or equal to the other. It returns a number negative for smaller, 0 for equals, and positive for bigger. Finally, the mismatch will compare your arrays until you where your arrays begin to be different. If the arrays are equal, this returns ‑1, or if they are different, this method returns the index position of the array where the elements begin to not match or differ. Again, watch out on the test when you see code examples with the arrays class. Make sure that both arrays passed in are the same array type. If not, you would end up getting a compilation error. There are a lot of rules around how these methods work. I've provided these rules and a few other cheat sheets on the GitHub address listed here. You need to understand the rules and make sure you spend some time experimenting with code around these four different comparison methods. As you can see that there are a lot of comparison rules when it comes to determining which array is bigger or smaller. Definitely take the time and look over the cheat sheets that I've provided for arrays on the GitHub site before you take your test.

Demo: Varargs and the Java "main" Method
If you remember when we created our ArrayMain class that we've been coding and working in, the method definition contained a string array. That parameter is often called varargs. When Java boots up and begins to run your Java program, the compiler automatically initializes and pass in the args seen here. All of the operations that we've done on arrays will work on the incoming args. What does Java put into these args? These args contain command line arguments that might get passed into the Java program. To see how this works in IntelliJ, you can click the wrench icon and modify your configuration. That icon is down here on the Run bar. And when you open that up, you'll see that there's a section in here called Program arguments. You can set a space separated list of strings here and Java will initialize them into the string varargs array. This can also be done from the command line if you're running Java as a program from there. IntelliJ just make this easy with their integrated UI. I'm going to pass in the following car manufacturers as program arguments. I'll click Apply and then OK. I can now jump to the bottom of my method where I've been testing code and add the following. When I run that, it should print out my car list that I passed in. You can see that it did that. It's pretty neat, right? As a side note, the Java main method can be defined in a couple of different ways. You can see that the basic way that I started out with here contains a [ ] args. You can also change it so that the brackets are at the end, like this. And finally, you can use the variable argument syntax like this. So which one should you use? It doesn't really matter. They all do the same thing ultimately, so it's up to your syntax preference.

Demo: Multidimensional Arrays
So far, every array that we've worked with has been a single dimensional array, or just a basic one row list of elements. In Java you can create an array with inside of an array. These type of arrays are called multidimensional arrays, and they are initialized like this. Note the double bracket syntax. Java will allow you to initialize a two‑dimensional array with the double bracket before or after the variable name, similar to as we saw with single dimensional arrays. You could make a three‑dimensional array with three brackets and so on. The more brackets you have, the more complex the nested array structure gets. You can initialize each dimension of the array however you'd like. That looks like this, and the syntax is very similar to single dimensional arrays. This sets the array to be a data grid with three rows and three columns, similar to a data table in a database, making the array fairly easy to picture in your mind. You can also set the multidimensional arrays to have different dimensional indexed values like this. That would mean for every first index position, that position holds 10 elements. You can also initialize the values on declaration just like single dimensional arrays, and that would look like this. Notice that not every row has the same number elements. This is not a problem for Java, and hopefully you see that all the same declaration rules apply to multidimensional arrays as they do to playing basic single arrays. Now let's check out what it takes to iterate through our 2D array of West Coast cities. Because we have an array within an array, we have to have a nested for loop to properly traverse the 2D array structure. Hopefully you can see how this is already more complex to deal with than a single array. To make things simpler, we can use the enhanced for loop syntax. That would look like this. The code looks a little more concise, but they ultimately do the same thing. We can see that by running this. Down here in the output, we have the cities printed out. Finally, let's see what happens when we use the array's toString helper on a 2D array. This code does compile, but what do you think is going to print out when we run this? Go ahead and do that. You'll notice at the bottom here we get some more strange memory address printouts of our array. So unfortunately, the toString is not a nested toString in arrays. It only prints out each slot in the first part of the array. If it's two dimensional, if you contain array in each slot, then it's going to print out the memory space of that. So if you do want to work with 2D arrays, you will have to write most of the helper functions for it, as the arrays class helper that Java provides is really only set up to work on single arrays.

Summary
We covered a lot on the array data type in this part of the course. Here are the basics that you should know for the test. You need to know how to declare and appropriately initialize single and multidimensional arrays and be able to look at code and determine if it is correct or not. You also need to understand how array object‑based elements are referenced and not stored like primitive values. Next, you need to understand how to iterate, sort, and search arrays. You should also be familiar with the helper Arrays class. Remember, that lives in the java.util package. And finally, you need to understand how to compare two arrays with each other using the equals, compare, and mismatch methods. Remember that there are a lot of rules around comparisons and the exam creators love to try and trick you. Make sure to study the cheat sheet resources and look at lots of code examples online or other books and resources that you can find. Now that we have the basic array out of the way, we're going to take a look at lists and collections coming up next.

Working with Lists
Introduction
Java arrays are considered a built‑in data type to the Java language. In this part of the course, we're going to focus on lists. This will be our first introduction into the Java Collections API, which is simply a set of classes that implement a variety of collection types. Again, there's going to be a lot to cover, so we'll go ahead and get started.

The Collection Interface
If you remember from earlier in this course, we looked over the collection hierarchy that Java provides. For this part of the course, we're going to focus on the classes and interfaces that extend from the main collection interface, and specifically the list interface hierarchy. The list interface defines a bunch of methods that all of the subclasses have to implement. Let's quickly take a look at the top‑level collection interface. I'm back in IntelliJ, and I can look at the collection interface by opening it using the Navigate class. Here I can search for any code, and if I type in Collection, you'll see that there is a Collection interface in the java.util package. I'll go ahead and double‑click that and open it. As we start looking through this, you can see that there are a lot of methods defined here. Some of these methods you should be familiar with and learn to use with the classes that implement collection with the size, isEmpty, add, remove, removeIfClear and contains, and finally, the foreach method. I know I just mentioned a lot of methods there, so we're going to dive into some of these specifically, which we'll do next. The most common list that Java provides is the array list, so that will be our focus coming up over the next few parts of this section of the course.

Demo: Intro to the ArrayList
I'm back in IntelliJ, and I want to create a new main class to put all of the list demo code in, so we don't get them mixed up with the array code that we've worked on. So I'm going to right‑click on com.pluralsight and select New Java Class, I'm going to make sure Class is selected, and this time I'm going to give it a name of ListMain. Next, I'm going to add a main method that we can put our demo code in. Like I mentioned, we covered array in the last section of the course, we're now going to learn about the ArrayList class. You can think of this like an improved version of the basic array data type. Let's take a look at what it would take to declare and initialize an array list. This is probably the easiest way to declare an array list, it works pretty much like any other Java object initialization. To make this work, however, you'll need to import it, and you should be familiar with the base package that all collections live in. That is the java.util package. I can use IntelliJ to import this, I'll just hover over and click Import class, and you'll notice that it brought it in from java.util at the top of my class. Let's check out a couple other ways you can initialize an array list. In the arrayList2 example, you can specify the size, as in this case, we set it to 100. Or, you can also create a new array list from another array list, as we've done in the third example. One thing to note about lists and array lists is that they are dynamic. If you were to set an array in Java to 100, it's set at 100 and the only way you can change its size is by declaring a new array and adjusting the size at that point. Array lists and lists are dynamic, however, and they can grow or decrease as needed. This makes for a far more pleasant experience coding than when working with the basic Java array. These three declarations are all pre Java 5.0, they're not using generics. For the test, you need to know that these still work and compile just fine, but they aren't seen a whole lot anymore out in the wild. Instead, you might see something like this now. Notice the string in brackets. Don't worry a whole lot about this right now, because I'm going to cover generics and typing later on in the course. Just know that both ways are valid ways, and when using collections, it's often best practice to reference the class by its parent interface rather than the implementation. This helps prevent tightly coupled code. So check out this declaration. If you remember, the list interface is the parent interface of ArrayList. Again, you need to import the list, so I'll go ahead and do that, and it again lives in java.util package. This is also a valid declaration too. This works because Collection is the parent interface of List and it's part of the hierarchy. Again, we'll need to import, and as you might have guessed it, this is in the java.util package. What do you think about this ArrayListt declaration? We've declared the arrayList6 as an ArrayList type, and then we set it equal to a new collection. If you're using an IDE, you will notice that it doesn't like it, IntelliJ is saying that we have a compiler error here. There's really two reasons for this. One, you can't instantiate an interface, and Collection is an interface. And second, you can't instantiate a parent from a more specific generic typing. So in this case, ArrayList is more specific, and Collection would be up higher in the hierarchy. It only works going the other way, such as Collection arrayList5 = new ArrayList. So since this line doesn't make sense, I'm simply just going to remove it. The remaining declarations are all valid, and you need to be aware when you see code declaring collections on the test, you just need to watch what they're trying to do. Sometimes they might trick you by putting a new interface at the end of the declaration, which just doesn't compile.

Demo: Using the ArrayList
Now that we know how to declare a list, let's see how we can use these to be a little more efficient and effective with them. ArrayList can add elements using its add method. Let's go ahead and add some elements to one of our lists. You'll notice on line 13 here I've declared an ArrayList that allows strings for the elements called colors, so I'm going to add some colors down here at the bottom and they'll look like this, red, yellow, and blue, our primary colors. The add method will take an object, and if using generics like we are here, it will restrict your type to that generic. So in this case, it's only allowing string objects. Note, you cannot add primitive types to ArrayList. They have to be objects. Java 5 added a concept called autoboxing, which will wrap primitive types for you in your collections. Again, we're going to discuss generics and autoboxing later on in the course, but know for now that collections require objects as their elements. There's also an overloaded add that lets you add an element in a certain place in the ArrayList. That looks like this, and it's essentially injecting orange, the color orange, in between red and yellow. Let's see what it takes to loop through an ArrayList and print out our colors. We can use a for loop just like we did with the basic arrays. There are a couple differences to take note here. First, we use the collection convenience method called size() to determine the length of the list rather than the arrays.length. The next difference is, once we're inside of the loop, we use the get method to retrieve the element at the indexed position of our list. The concept is very similar to arrays, but the syntax is slightly different. Again, we can use the new for loop style like we did with arrays as well, and that allows us to just print out the colors using each iteration stored in the String color variable. As of Java 8, though, a new loop option was added to the collection interface. That looks like this. It defined a forEach method. This style of looping is very similar to scripted languages like Python or Ruby. We've seen how to add and get elements in a list. Let's see how we can delete an element. You can remove an element in one of two ways. You can specify the exact element, like the color orange, or you can remove it based off of the position that it lives in. I'm actually going to move these lines above the last loop so you can see that the elements were removed when we run it. To run our list code, I'm simply going to right click and just say Run ListMain. Now if we look at our kind of confusing print out, we have red, orange, yellow, blue, which is this first for loop. Then we have red, orange, yellow, blue again, which is the second for loop. We then issue remove to orange, and we print it out again, and we're left with yellow and blue. What do you think would happen if I did this? Inside of a for loop, I issue a call to remove the current index that I'm on and then see what happens to print out after that. Would you guess that it would remove all the elements, and we would end up with an empty list? Let's go ahead and rerun our code and see. Why did we end up with blue still in the list? That's because as we removed the yellow value, it reduced the size and ended the loop on the next iteration, essentially short circuiting the for loop. So removing elements in a loop is typically not the best practice, as you can get unexpected results. There's also a gotcha if you're using the newer for loop syntax and removing an element. Check out this code. What do you think would happen when we run this? Well, let's go ahead and try. We end up getting a ConcurrentModificationException. Java does not allow for element removals while looping in this case. I'm going to go ahead and comment out this for loop, since it compiles, but it throws an exception. Again, there's a few more methods that you should be familiar with when using ArrayList. I've added an ArrayList cheat sheet out on the GitHub repo that we've previously used that you should go take a look at and see what you need to be familiar with for the test. Take some time and play around with ArrayList. You're using an IDE, it offers a lot of options, because I can inspect the methods that are available to me, and I can try them out and see how they work. Up next, let's cover how to convert arrays to lists and vice versa.

Demo: Array to ArrayList and Back
Earlier, we covered all things with the basic Java array, and we've just finished talking a little bit about the ArrayList. Let's see how to convert between them. We can begin by turning a list into a basic array. Here's how you can do that. I'm referencing the colors ArrayList that we previously created. And this line of code returns all of the colors back as a basic array, which you'll notice I've set to the Object type with the square brackets. We, however, have all of the colors set as strings. If you were to try and set it to String instead of Object, you would get a compilation error. There is an overloaded version of toArray, like this. Notice that in this form of toArray, it takes in whatever type of array and it will return that same type. If you wanted to keep the colors as strings, you could use this. This method will actually try to use the array passed in to populate the ArrayList elements. If it's not big enough to hold the list elements, it simply creates a new one. In this case, we passed in a 0 length array, and a new array would have been created and returned. Again, you can use your IDE to inspect what's happening here, and you can see the various forms of the toArray. Now let's see how to go the other way and turn a basic array into a list. In this code snippet, we start with a basic String array, which is holding shapes. We have square, circle, and triangle. We're then going to reference the Arrays helper method to return a new list. But in order to do so, in the code I'll need to import this, which I have not done yet in this class. And then finally, we'll print out the shapeList. We started with a String array, and we create a list, and then we print that list out. The question for you is what kind of list do you think this is? Is it an ArrayList or something else? We can actually find out by calling getClass().getName(), which will print out the type of list that this is. So I'm going to go ahead and save this and run the code. Down here towards the bottom of the output, you can see that we printed out square, circle, and triangle, which is from our System.out right here on line 52. And then it prints out java.util.Arrays$ArrayList. You might think that this is an actual ArrayList, but note that this is an inner class of Arrays. Arrays is the outer class, and ArrayList type is the inner class. If you wanted to see what a normal ArrayList would look like printed out this way, we can do that on the colors ArrayList that we've created, and that would look like this. So let's go ahead and run the code again to see what colors prints out. In this case, in the output you'll notice that the actual colors is a type ArrayList from java.util. So what's actually happening here? When you call Arrays.asList, it returns a fixed size list that matches your string or array that you passed in. You can change out the elements, but you can't remove any elements from the list. That means I could swap out square with something like a rectangle, but I actually couldn't remove the square element. If you try to call remove, it would throw an exception. So this type of list isn't quite immutable, meaning that you can't change it at all, but it is a different flavor of ArrayList than we're used to. Let's look at another way to create a list from an array. Here we created a new shapeList2, and this time we're using the List interface. The Java List interface defines a static method called of. This returns a list, but it's also a special type of list. This is an actual immutable list, meaning it can't be changed at all. So notice what will happen if we try to add a shape to the shapeList2. We can do that by calling the add method. We'll save this and run the code. And you can see that we get an exception. We get an UnsupportedOperationException. So far, we've seen two ways to create lists from arrays, but they're special types of lists. One is kind of a semi‑immutable list from the Arrays helper class, and the second is an actual immutable list from the List interface. Since this line doesn't work, I'm simply just going to comment it out. So my final question is, how do you actually create just a normal ArrayList from a basic Java array? Hopefully, you might have guessed that you have to do it the old fashioned, difficult way. You simply loop through the array and add the elements to an ArrayList one at a time. And that code simply looks like this. At the top of this code block, we define a new list, ArrayList type. We then loop through all of these shapes, which comes from our string array up here. And then we add each of those array object elements, such as square, circle, and triangle to the shapeList3. And when we're finally done, we can print them out, which would be an actual mutable ArrayList type that we're used to working with. We can test that out by running the code. And at the bottom of the output we do have a square, circle, triangle. And if you'd like, you can do a getClass().getName() on it, and it will return a java.util.ArrayList. We've seen how to go from a basic array to a list. Let's see how we can go back the other way. If you already have an ArrayList, you can create an array from a list using the list's own helper method. That would look like this. In this case, I'm using the shapeList3 and calling toArray on it and returning the array back. These functions or methods work pretty much the same as the Arrays helper listed up above, but you're already in a list and you're going the other way. That completes the primer on our ArrayList type. Coming up next, we're going to take a look at LinkedList, which is a slightly different version of a list.

Demo: The LinkedList
The LinkedList data collection is another interesting list type. It implements the list interface same as the ArrayList, but it also implements the queue interface. So let's declare a linked list. I'm still on my ListMain.java class. I'm just going to come down to the bottom here, and I'm going to define a new LinkedList like this. And again, the LinkedList has not been imported into the class, and if you would have to guess which package does this live in, hopefully you guessed java.util, because all the collection API classes live there. I'll go ahead and import this class so that we can use this. In this case, we're creating a LinkedList and we're typing it to string elements only, and we're calling the variable name orders. If you think about the concept of orders, they come in a certain order or arrival, and you need to keep track of that particular order of arrival. So we need to make sure that they are handled as they are received. We'll want to handle these as first in and first out. And again, if you remember back, that's the definition of a queue. So in this case, the LinkedList is a perfect collection for this need. Here in this code block, we can add orders using the standard list add method that we saw with ArrayList. But LinkedList also has some additional accessor methods that are coming from the queue interface. Since queues want to understand how to add at the beginning or possibly at the last, depending on if you're doing a queue or a dequeue, you can use the addFirst or addLast method. So let's go ahead and save this and run, and you can see how the order 4 and order 5 get placed into the LinkedList. In the output stack, the first orders that we receive are just the basic orders that we called with add, order 1, 2, and 3, and finally, after we do the first and last, you can see that order 4 was placed at the beginning of the queue, since it arrived in a certain order and order 5 was placed at the last. If you were truly receiving orders in real time, you would simply just say addFirst as they arrive, and everything will get placed and shifted over correctly, like you would expect from a queue. Removing elements from a LinkedList can be similar to ArrayList because it's a type of list, but if you want to get the queue functionality, you can use the following methods. Queue provides a removeFirst and a RemoveLast method, and if we save this and print it, you can see that that code removed order 5 and order 4 in the appropriate order, and we're left with our order 1, 2, and 3. As the name implies, LinkedList is a type of link from what element to element, similar to a chain. In this case, you can insert links of the chain in a more performant matter than, say, an ArrayList. LinkedLists just sever the chain and reattach where needed. ArrayList's remove or add methods are going to have to shift the other elements out of the way. Other than the new queue methods provided in LinkedLists, the list section of LinkedList are very similar to ArrayList and perform all of the same functions. And that's it for understanding LinkedList and the basics about them. Just keep in mind, if you see questions on this particular collection, just know that it implements the list and queue interface. Up next, we'll talk a little bit about sorting lists.

Demo: Sorting Lists
If you can remember back when we worked with basic Java arrays, you can sort those arrays using the Arrays helper class. For collections, there is a similar class. And guess what that's called? Of course it's the Collections class, and it is a helper class as well. Do not get collections confused with collection interface. They're two different objects and types in the Java language. So to see how this works, let's create a new numbered list that isn't ordered to test it out. I've declared a new list called numberList, and I've set it to an ArrayList type. I then added some numbers in random order: 10, 5, 1, 3, and 9. Now, we can go ahead and sort it using the Collections helper class, and that would look like this. Before I actually do the collection sort, I want to print out the numbered list so you can see the order as they were added. That's what this first System.out does. Then, I call Collections.sort, which is going to sort our list, and then I'll print out the collection afterwards. Before running this, I'm quickly going to jump to the top of the class and look at the imports. In this case, IntelliJ has tried to optimize our imports by reducing the number listed here by simply just starting to include all of the java.util package using the asterisk. What I do want you to know is that there is a Collections and a Collection. And note that Collections is a type of class and Collection is an interface. I just mentioned that these two things are different. Collection is our parent interface for all of our collections, and Collections, plural, is a helper class for the collections. And back down in our code, I'm using the helper class to sort the numberList. So let's go ahead and run this. The output, the second to last line, prints the numbers as we ordered them, 10, 5, 1, 3, 9. Following that, after we sort it, we now see that the numbers are sorted as 1, 3, 5, 9, and 10. As you might imagine, sorting numbers or even strings alphabetically is fairly easy to do. But what if you have an object that needs a special sorting algorithm? Maybe you have a person object and you need to sort by their street address or some other characteristic or attribute on that object. Fortunately, Java has a solution for this that allows you to handle sorting algorithms and customizations. The solution is called comparators and comparables, which we'll cover coming up next.

Comparable and Comparator
Java provides two ways to allow you as the developer to set up the sorting algorithm. Let's take a look at the Comparable interface first. Comparable is an interface, and it has one method on it, the compareTo. This interface is meant to be implemented by the object that you want to add sort capability to. It lives in the java.lang package, which means that you don't have to explicitly import it. The defined method, compareTo, takes in one parameter. Even though it looks strange, T is a generic type, and it allows the compiler to set the type at compile time, as needed. A Comparator type, on the other hand, is a functional interface. It's meant to be used to sort a class that you either don't have control over, but you need to sort, or if you want to use it with a Java lambda function. This class lives in the java.util package and requires an import to use. This is an important distinction, and sometimes the test exam creators will try to confuse or trick you based off of these two types. Also note that the comparing method is named slightly different in this interface, it's comparing with two parameters instead of the compareTo method, and it's simply called compare. To pass questions on Comparable and Comparator on the exam, you've probably asked about the differences between these different types. Again, they may try to trick you by mixing up the compare and compareTo methods or the parameters. So how do Comparable and Comparators actually work? Let's quickly set one up. We first need an object to sort. So I'm going to create a new class by right‑clicking on com.pluralsight and selecting New Java Class, I'm going to call it Mountain. This class will represent a mountain, similar to like Mount Everest or some other mountain, and mountains usually have a name and height, so I'm going to add attributes for those. The name will be a string, and the height will be an int. Next, I'm going to right‑click and create getters and setters for these attributes. In IntelliJ I can do that by generating getter and setter, I'll select all of my attributes and click OK, and finally, I want to add a constructor. I've placed the constructor just below the attribute declarations, and it takes in a string and int to set the Mountain attributes on construction. At this point, we're ready to try an order. So which interface should I use here? We want Comparable, because this is the object we are comparing. So the next thing I'm going to do is implement that interface. At the top of the public class definition for Mountain, I'll add this, implements Comparable, and I've given it the Mountain type because I'm a type of mountain, and again, IntelliJ is giving me an error, saying, hey, you need to implement the method along with Comparable, but notice that I don't have to import Comparable because it's part of java.lang package. The method that I need to implement is called compareTo, if you remember from the previous slide, and will take in a Mountain, and then we need to actually do the compare logic here. So here's a quick overview of how comparing objects work in Java. If the objects are equal, you want to return 0. You'll notice the compareTo returns an int. If the object is less than the passed in object, we're going to return ‑1, and if it's greater than the passed in object, we return 1. This simple mechanism allows the store algorithm to easily shuffle objects by just seeing if the return value is less than, equal, or greater to the previous value that it compared. So here's my implementation to compare by height. This simple compare logic simply takes the mountains and orders them lowest to highest in height. If you wanted it to be the other way, highest to lowest, you would simply adjust as necessary by putting the o.height first, minus this.height. I can now jump back to my list main class, and I can try sorting or ordering mountains now. So I've created a new list of type Mountain, which is an ArrayList type, and I've added three mountains with their height in meters: Mount Everest, the Matterhorn mountain, and K2. As you can see by the height, they're not in order. So in this next block of code, I'm simply going to use the Collections.sort on my mountains, that mountains will then utilize the Comparable that we added to the mountain object, and then this System.out is a fancy way to print each collection element. I'm using part of the stream API, we won't get into this, that'll be covered in a different course, but essentially, this will print out each element and I need to import the Collector's object. And again, the code in the System.out you don't need to know for the exam for collections, but possibly you will for streams. I'm going to go ahead and run this and see if it orders the mountains correctly by height. As you can see on the last line of code, we have the Matterhorn, K2, and Everest. Next, let's code up a Comparator to see how it differs. Comparators are built and defined outside the class that you want to compare. This code might look a little strange, but I'm essentially implementing the compare method as an anonymous inner class directly in my code here. This time I've changed the logic to print out the mountains from highest to lowest. Again, note how this is different, the compare takes in two objects, the beginning and the next object that it's comparing, and then you can choose how you want to implement the return value. Next, I can call the sort method again, but notice it takes a second parameter this time, which is my mountainComparator. If I didn't add that or pass that into the sort, it's going to fall back to the Comparable that I set up in Mountain. And then again, I just print out each element of the list. So let's go ahead and run this. So the first sort used the Comparable, which listed the mountains from lowest to highest in height, and the second Comparator overrode that and listed the mountains in highest to lowest. If you notice the Comparator anonymous inner class is kind of bulky, it takes up a lot of code. We can actually clean that up by using a lambda function. You can see here in this code snippet that the mountainComparator2 is a lot less verbose as far as code is concerned, but does the same thing, essentially uses the height to adjust the sorting algorithm. Just note that there's a lot that can be done with Comparable and Comparator. You can compare multiple attributes, you could even compare nested objects if you really wanted to. But like most things, when you start creating custom code, you have to worry about things like null checks and proper equals, and hashCode implementations on custom objects. These are all standard best practices, however, when using Java. When you see code examples on the test, really look over what is happening and watch to see if they're trying to trick you based off of them using the Comparator or Comparable attributes, types, or method names.

Summary
Here are the high‑level takeaway points for lists. Lists are index‑based, like arrays are, and lists can contain duplicate elements. The hierarchy for an ArrayList is the List interface and the Collection interface. Each level defines methods applicable to that type. The LinkedList hierarchy is the same as the list, but it also implements the Queue interface. You need to be familiar with the Collections class helper. This class has methods like sort and search to help you work with Java collection types. Finally, you need to understand the differences and similarities of the Comparable and Comparator interfaces and how they are used to provide custom sorting for your objects. Knowing what the compare or compareTo method name is and what package each of these interfaces live in may be needed on the test. The really nice thing about modern day IDEs like IntelliJ or Eclipse is that you can get method completion help when working with the code. Spend some time looking over the methods available on ArrayList, List, and Queue, and write up some tests and sample code just to see how they actually work. This will help you to understand collections better, as well as just make you a better overall engineer as you test and experiment with Java code. That's it for lists. Next up, we'll dive into sets and maps.

Working with Sets and Maps
Introduction
Welcome back, and we're going to continue our collection exploration by talking about sets and maps. Most of the concepts like declaring, iterating, and using helper methods that we saw for lists, will be very similar or identical for sets. Maps, however, are fundamentally different than sets and lists but won't be too hard to pick up. We'll start out this part of the course looking at sets. What is the difference between a set and a list? There's two things a list can do that a set can't. One, it can contain duplicate elements, and two, its contents are order based, and they're based off of the index position. Sets, on the other hand, don't contain an implicit order, and a set can't have duplicate elements. Those are the main differences. Let's see how Java fits sets into the collection hierarchy.

The Collection Interface
Here's our Java Collection hierarchy again. We've already talked about the List interface and a little bit about the Queue. We're now going to focus on the Set interface. You can see that it extends from Collection as well, so any methods on the Collection interface will also work on sets. There's two common sets Java provides, the HashSet, which is used quite often, and the TreeSet, which you won't see as much out in the wild when programming, but still is a valid data collection type. I've jumped back over to IntelliJ because I want to open up the Set interface and take a look at some of the methods. So I can navigate to that by typing in set. And I'm going to find the Set in the java.util package. Again, Set is an interface type. And many of the methods, like size, isEmpty, are common and self‑explanatory. However, there's two things in here that you should take note of. First, there is a method called HashCode. This method is how we index and identify the elements in our set. It essentially provides the uniqueness factor for our set. As we scroll down towards the bottom, you'll notice that there are some static helper methods that you can help create immutable and unmodifiable sets. This is similar to the method helpers in the List interface that we use to create lists. Up next, we'll see how to use the basics of HashSets and TreeSets.

Demo: Using HashSet and TreeSet
Since Set extends from Collections, most all of the methods that we use for list will apply to sets, too. The big difference between them is that sets don't have an index position like lists do. So any list method that takes an index won't be valid on a set. I'm going to start by creating a new main class that we can use for demoing code. So again, I'll right‑click on com.pluralsight, select New Java Class, and this time I'm going to create a class called SetMain. I'm also going to add a public static void main method so that we can execute the code as needed. That will look like this, and hopefully that is comfortable and familiar to you by now. At this point, HashSet and TreeSet both live again in the java.util package. Here's an example of how to declare each of these collection types. Since I've added two new classes here, I need to import them. So I'm going to do that by calling Import class for the HashSet and Import class for the TreeSet. And as you can see at the top here, those both live in java.util. Note that I'm using Generics to type the elements to integers for these declarations, and of course, we'll talk about Generics at the very end of this course. These are valid declarations, but remember, it's often preferred to hold the reference to the Collection variable by the interface rather than the concrete class. So I can update these to, say, <SetInteger> rather than HashSet or TreeSet, and since I've introduced a new type to the class, I'll go ahead and import that, and hopefully you can have guessed by the variable names that have given these sets that we're going to be adding prime numbers to them. So let's quickly add some prime numbers to the set. Okay, I've added a fair amount of code here. Let's see what this is doing. I first started by creating some numbers in a HashSet. These prime numbers are added in random order. I then added the same set of numbers to primeNumbers2, which is of type TreeSet. I then print out the prime numbers in the HashSet, followed by an empty line, which is this middle System.out, and I end with the printout of the TreeSet prime numbers. I can now run my code to see what happens by adding these numbers. Let's take a look at the output. For the HashSet, it printed out the numbers, but they're not necessarily in the order that we added them. So sets don't preserve your order like a list would; however, notice what happened when we printed out the TreeSet. The TreeSet printed out the numbers in sorted order. So the main difference that you need to know between HashSet and TreeSet is that the TreeSet orders the elements as they are added to the set. We've already talked about how sets can't contain a duplicate element. Let's see what happens if we try to add a duplicate element. So in this snippet of code, I'm adding the number 5 to primeNumbers1, which is HashSet, and then I add it again, but each time I add it, I actually call System.out to return the Boolean value to see if it added successfully or not. We'll save and run this. Notice what happened on these adds. We did not have 5 to begin with, so it said that the add was true. The second time we added the 5, we get a false back. So sets don't necessarily throw an exception if you try to add a duplicate element, it just won't add it. You might have noticed when working with a collection like a list, why the add returned a Boolean, simply because, in this case, it may not add the element, whereas in a list it should always add the element. Other methods on sets are very similar to list and the Collections. I can remove an element, and then I can print out if it's empty or the size of value. Take a moment and explore the method offerings on Set and try out some of your own demo code. You can see at this point that sets really do enforce unique elements. The question that you should be asking is, how do they know if an element is a duplicate or not? We'll answer that coming up next.

The HashSet hashCode Method
When you add elements to a HashSet, you're really adding the element as a key‑value pair. The value is the element, and the key is what's known as a hash. Here's an example of a HashSet of the primary colors. The colors are represented as a string data type, and the string class has implemented hashCode(), so each string creates a unique int. You can see the hash codes below each color. When red is added to the HashSet, the HashSet looks for a key of 82033. If it exists, then the add method returns false. Otherwise, the element gets added and associated with that hash. Because of the key‑value pairing, HashSet is very performant when adding objects to the set, and it can be more performant than a list. The hashCode() method definition returns an int. If you create a custom object, it's up to you to create a valid hash code implementation for your object. That way, if it does get put in a HashSet, it will get set correctly and ensure uniqueness. If you remember back to the mountain that we created, we would probably want to create an equals, toString, and hashCode() implementation for our custom object for reasons like this. The main takeaway here is that a HashSet is like a list, but his indexed by the hashCode() instead of an indexed position. HashSets enforce uniqueness of elements and are not ordered. TreeSets are ordered. Let's see how those are implemented next.

The TreeSet compareTo Method
You might think that the TreeSet uses the hashCode method to determine if elements are unique, similar to HashSet. It could, but since elements are ordered as they are added, it actually uses the comparable concepts that we talked about earlier. Here's what the primary colors would look like if they are placed in a TreeSet. You'll notice that the structure actually looks like a tree. The string color names are ordered as they're added. If the alpha characters of the element added are less than the top tree node, it gets added to the left. If it's greater than the top tree node, it gets added to the right. The main method for this is the compareTo method from the comparable interface. If you're confused on this, go back to the last section of the course and look up the comparable and comparator section. The nice thing with TreeSet is the elements are ordered as they are added. There's no need to really call the sort function because the elements are already sorted. That brings us back to the HashSet. Is it possible to sort a HashSet? You might be tempted to send a HashSet to the Collections.sort method like we did with the list, but that actually won't work because that method only takes a list interface type and not a set. So the short answer is no, a HashSet can't be sorted using the Collections helper class. Next up, let's take a look at maps.

The Map Interface
I'm back to the Java hierarchy overview for Collections API. You might be getting sick of this at this point, but this actually is helping drill in this overview, and it will help you when it comes to the test to remember what is what. As you'll notice, off to the right, Map is on its own. The Map interface doesn't extend from Collection. Maps are different enough that it will provide its own hierarchy, which we'll take a look at. There are two common maps Java provides: the HashMap, which you will see and use often, and the TreeMap. These implementations are very similar in concept to the HashSet and the TreeSet that we just talked about. And as you might guess, the HashMap is unordered, whereas the TreeMap is. I'm going to open up the Map interface by navigating to it in IntelliJ. Here's our Map interface in the java.util package. You'll first notice that it defines similar methods as Collection does, size, isEmpty, and so on. As you begin to browse further down, you can see that there are key‑specific methods in here, like containsKey and containsValue. That's referring to the key value mapping that Maps provide. The two methods that are useful for accessing and getting elements inside of a map are the get and the put. Again, these take keys and key value pairs, which is what Maps are all about. Coming up, we'll take a look at HashMap and see how it implements the Map interface.

Demo: The HashMap
The HashMap is similar in concept to the HashSet that we've already talked about. Both contain key‑value pairs. The main difference is HashSet auto creates a hash key for you, whereas the HashMap requires you to provide the key. Here's the basic rules with a map, keys must be unique, but values can be duplicated. I'm going to create another main class just so we can keep all of our data classes separate. So I'm going to right‑click on com.pluralsight and click New, Java Class. This time I'm going to call it MapMain. And I need to give it a public static void method again. So I'll put that in here. And we're ready to start coding some HashMaps. As usual, we'll first start by declaring some HashMaps. Here's four different declarations, and because I haven't imported HashMap or Map yet, I need to do that. And these, again, are in java.util. So I'll import that, and you can see them coming in here at the top. And I'll take the Map and import that as well. And again, the Map is the parent interface for all maps. So let's talk about each of these. The first is declared without generic typing. This is how code looked in the Java 1.0 days. The second declaration contains the generic typing, and there are two differences here versus sets, lists, and queues. You'll notice that we're taking in two generic types, an integer and a string. The first type is the key, the second type is the value. The third declaration uses the Map interface to hold the variable, and the fourth declaration uses the Map interface to hold the variable using generic typing. If you were to code these in a real‑world project, you should want to use probably the fourth declaration. To add elements to a map, you'll want to use the put method, which will look like this. The first parameter is the key and the second is the value. This shows how to map the country number code to the country alpha‑3 code. If you've ever worked with a relational database, like Postgres or MySQL, Map should feel familiar since database tables maps a row of data to a primary key. Here's how to retrieve a mapped value. You need to use the get method and pass in the key that you want to return the value for. We can go ahead and save this and see if we get the appropriate value back by running MapMain. You'll notice in the output here that USA is returned because if you look up here on line 13 we said the key for USA is 840, and then down here we retrieved it and printed that out. To delete a key‑value pair from a map, you'll want to use the remove method. The Map remove method takes in the key. And by specifying the key, your internal map implementation will know which value to remove for that key. When working with a map, you may need to work with the keys or values as a collection. Map provides a way to get a keySet like this. This returns all of your keys in your map. It's a set type because, if you remember what I said earlier, they are unique and can't be duplicated, which is exactly the definition of a set. What would happen if you put a key value in twice into your map, something like this? We begin by mapping CAN to the key 124, and then we follow that by mapping ABC to 124. In this case, we don't actually add two new key‑value pairs here. Instead, the second put overwrites the value of the first put. This is something that you need to be aware of when using maps. You'll always want to be checking if the key already exists or not before working with the map. If you want to get all the values in the map, you can use the values method that the map provides. That looks like this. You can see here the values returns a collection. Because values can be duplicated, this is not a set, but it's going to be a type of list or plain collection. I just mentioned that it makes sense when working with maps to make sure that you have keys, or possibly values, before you do any kind of get or put operation on it. Map provides two methods that can help with this, which are conditional‑based methods. They return a true or false. Those methods are the containsKey and the containsValue method. As the method name suggests, if you pass in the key and it does contain the key it will return true. Otherwise it returns false. The same logic applies for your contains value. Finally, something to consider when using a HashMap is that the values can contain null. In this key‑value pair, I can map the key of ‑1 to a null type. Something else a HashMap allows for, which may be not very intuitive, is you can actually place a null key as well, as long as there isn't one already set. In this case, I can map null to null. This isn't very good code, but note that HashMap does allow it. Also note that not all maps allow null keys. One such map is the TreeMap, and we'll go ahead and take a look at that coming up next.

Demo: The TreeMap
As far as declaring a TreeMap, it's going to look very similar to HashMap. You simply just need to use the TreeMap class name instead of HashMap. Here are two basic TreeMap declarations. This should start to feel familiar to you by now. Again, we haven't used TreeMap yet, so we need to import it, and if you were to guess which package it is in, yes, it is in java.util package as well. Now that they're imported, the two types of declarations could be the old non‑generic type, which I don't have an example here. Both of these are using generic typings. The first one is referencing a TreeMap with the key of an integer and a value of a string, and the second declaration is using the Map interface to hold the TreeMap. Again, this is generally preferred when coding. Adding elements as key‑value pairs will be the same as HashMap. For example, you can see that it's easy to map the planet position from the sun, or an English‑to‑Spanish translation. The puts work just like a HashMap, but here is where the difference happens between the two. Let's print out the keySets for each of the maps to see how they can differ. When I run the output, you can see that the keys are listed as 2, 3, 4, and the Spanish‑English keys are listed as cat, dog, and fish. Since you're already familiar with TreeSet, you might have guessed that this is adding key‑value pairs in sorted order. The TreeMap orders and stores the keys of your map, but not the values. You should probably know that the TreeMap structure is built off a data collection type called a red‑black tree. It's a data structure that is a tree and re‑balances and sorts, as you add entries into it. You don't need to know the details of a red‑black tree for the test. However, it is good to know that TreeMaps are going to be less performant because of the sorting and re‑balancing that occurs while using the Map. You also may be surprised that a TreeMap can contain null values such as this example here. If you think about it, this does make sense because the values aren't ordered or sorted; it's the keys that are ordered or sorted. What do you think would happen if we were to run this code where we put a null and null in a TreeMap? Let's go ahead and do it. The Compiler doesn't seem to care, but when we run the output, we get a NullPointerException. TreeMaps require non‑null keys to be added, because it uses that value to determine how it's placed in the red‑black tree. Therefore, it can't be null. You know most of the fundamental and conceptual differences now between sets and maps and the other collection types that we've talked to, but I would like to make sure you refer back to the GitHub repository that I've shared with you earlier in the course, because I have provided some more cheat sheets around maps and sets.

Summary
To be successful with passing the collections portion of the exam, you need to know the conceptual differences between sets and maps, as well as the other data types. But you also need to know many of the methods and syntax with them. First, remember that sets are unique and implement the Collection interface. HashSets use the hashCode method to store the element. TreeSets use a comparable and stores the element ordered. Maps are a standalone Collection type, and all extend from the main map interface. HashMap is unordered, whereas TreeMap does order its keys. This wraps up the main collection classes overviews that might pop up on the exam. The last thing that we're going to talk about is, we're going to go in depth on generics and typing, specifically with collections. We've already seen examples of this in all the demos we've written, but we'll cover exactly how they work and what they do in more detail in the next part of the course.

Understanding Generics
Introduction
In our demos, we've already seen how Generics can be used with collections. We've talked about them briefly in the previous sections of this course. Ultimately, Generics are used as a way to force a type to happen during compile time, but may be unknown at coding time. With collections, you may want to force a certain type to only be allowed as elements in the collection. Generics allows this to occur. Let's take a look at some code as an example. When you declare a basic array, it allows any object to be added to the collection. Here we add an Integer, followed by a Long, followed by a String, and finally a Double type. This is valid Java code and compiles just fine. What will happen here when you loop through the array and do some work on the numbers? Because we're casting to an int, you ultimately get a class cast exception when the second iteration of the loop tries to cast a long to an int. By using Generics, you can prevent this from occurring. If we declare the list with an integer type, we no longer have code that compiles. The Compiler requires all elements to be integers. In this case, the Long, String, Double won't compile. Let's take a deeper dive with Generics and see how declaring and initializing Generics on a custom class works.

Demo: Defining a Generic Class
Generics are defined and declared with what Java calls the diamond syntax. That is the less‑than and greater‑than symbols put together. Let's create a new Java class. We'll again right‑click on com.pluralsight in IntelliJ, and select New Java Class. For the class name, we're going to call it Widget, and it will just be a plain Java class for now. At the time of me coding this class, I don't know what type of objects this widget can hold or use. So this is a perfect scenario where a generic typing can help. To add generic, it will look like this. The <T> syntax tells Java that you can define the type later. The Compiler will resolve at compile time. The capital T can now be used inside of the Widget class. Here, I've defined a private class attribute of type T, and I gave it a name of type, and I'm going to go ahead and create getters and setters for it as well. I'm going to use IntelliJ to help me with that. I'll just right‑click inside the class, and say Generate, Getter and Setter, I'll select my type, and click OK. You'll notice that throughout this class, the compiler is allowing me to use T. At this point, I've created a basic Java class, and I've given it a generic typing. Let's see how to declare and instantiate our new generic class. We could instantiate this in any of our other main classes that we've created, but I'm just going to add a public static void main method to the Widget class so that we can use this class for our example. I could declare the public static void just anywhere in this class. I've chosen to put it at the top. Now we can get down to actually instantiating and declaring a widget type variable. Here's my new Widget declaration, and two things that you should note here. After declaring the Widget class, you can see that I set the generic type to be a string. So this means anywhere in the class where we use the T object, it's now compiled to a type string, and the compiler will enforce that at compile time. Notice what happens when I call widget.setType. You'll notice that IntelliJ and the Java Compiler are telling me that the parameter type needs to be set to a string. That's because the compiler knows that we've declared the generic type to be a string when we declared our widget class. So I can go ahead and populate the incoming parameter with a Java string. The other thing to note here is that after we said new Widget on our declaration line, we used the less‑than and greater‑than sign brackets without specifying anything, and in fact, in some of our earlier demos, we use this same type of syntax. This is sometimes called a diamond since it looks like a diamond. The Java Compiler will automatically assume the declared generic. In this case, the declared generic begins with Widget<String> at the beginning of our class declaration. What do you think is happening here in this declared widget? This is valid Java code. Since we didn't declare the generic type initially, which we don't have to, when you get to saying new Widget, if you use the empty diamond bracket, the Java Compiler will default to set the generic type to the base Java object. Since the Java object is the parent object of all objects in Java, it's really no different than if you declared the widget like this. In this Widget declaration, we're essentially using early Java code before Generics was available and type casting was available. Now that you've seen how to declare a generic class, and how it works with instantiating it, let's take a look at some of the Java Generics naming conventions coming up next.

Generic Naming Conventions
Java has set some naming conventions when you use generics. If you're going to create your own custom generic classes, you should consider following these conventions as well. These conventions come straight from the Java docs, and we defined our widget class using the capital T for Type. Relating generics to collections, you'll notice that the Java developers have used a capital E for Element, a capital K for map Keys, and a capital V for map Values. Let's jump back to IntelliJ and look at some collection code and their use of generics. So let's start by opening the Collection interface. Collection is in java.util. Let's reopen that up. If we come to the top of the Collection interface, you can see that the interface is defined with a generic definition, using the capital E. You should also take note that generics work just fine in interfaces, as well as classes in Java, as you can see here. Let's scroll down to where the add method occurs in the collection. Here, you can see that the capital E is referenced again. At compile time, all of the generic types will get typed and checked for you. So if we add a string to the collection, as a generic typing, all of our methods that use E will be set to string. If it's an integer or some other custom class like a widget, it will all get type and checked for that particular typing. I'm going to open the Map interface next. If you remember, Map is a standalone interface. It doesn't extend from Collection. You can see here that Map is implemented using two generic types, the capital K and the capital V, and you'll notice that the parameters up here, the type parameters right above, and say that this is for keys and values for your map. The other interesting aspect here is that you can define multiple types on your interfaces and classes in Java that are just separated by a comma. So in this case, Map has two generic types, K, V. And if you're defining your own generic classes, you can set up as many incoming types as you would like or need for your needs. Coming up next, let's see how generics work on methods.

Demo: Defining a Generic Method
At this point, you should be familiar with how generics works when applied to a class or interface level. Not surprisingly, generics can also be applied to methods. They are especially useful for static methods since static code stands on its own. I'm going to define a new static method within inside the Widget class, and it will look like this. I've added a method to the bottom of my class, you'll notice that it's a public static method, and I've called it firstArrayElement. Let's walk through what's happening here. The first necessary part is the <T> right after the static declaration. This tells the Java Compiler that this method will be using generics and the generic typing syntax will be the capital T. After the <T>, you can specify the return type for the method. And in this case, I've decided to return the T type. And then in the parameter, you can also use the T typing. And in this parameter, I'm passing in a primitive array of type T, and I will do some kind of operations on that. One thing to take note of here is the capital T declared in this static method is not the same type as the class capital T defined at the top of our Widget class. Don't get the T types confused if you see code like this on the exam. Here's an example of how to call our new static method. I've jumped back up to the static void main method to run this code, and I've declared a new primitive String array, and I have two elements in it. I can next call my static method saying Widget.firstArrayElement, pass in the String primitive array, and then print it out with the System.out. If you go back and look at the firstArrayElement static method definition, essentially, what we do is we take the incoming primitive array, and here, you can see a I say, t.length, if it's greater than 0, I want to return the first element; otherwise, we'll just return null because we don't have any elements inside of the array. But I'm using the T typing here. What happens is when I run this, which we can do by right‑clicking and say Run Widget.main, you'll see that the output spit out the first element in our string array, which says, Hi. The static method that we've created now works with any type. And as a developer, I can then restrict it to that type. So I could make all of my String arrays passed in here be forced to use strings, or I could use any other Java object type. Coming up next, we'll talk about generic wildcards because generics are not generic enough sometimes.

Generic Wildcards and Bounds
The Java generic types allow you to set an unknown data type at code time. You may be surprised to know that you can create a wildcard generic type. Wildcard generics are used when you don't know what the type will be. They are often used in parameter types like this, where we don't necessarily know what the list element types will be. The <?> syntax is known as an unbounded wildcard. That means that the compiler will accept any Java type here. You might ask yourself, why not just use an object or the plain list since you don't know the type? Well, if you're working with a class that declares a generic typing, this will keep your code consistent with how that class is declared. Wild cards become more interesting because we can put bounds on them, and this is where you can really start to add some real touches to your generics codes. To be more restrictive and precise with generics, you bound the wildcard to an upper bound, as seen here. The compiler will allow the type passed in to be an instance of string type or any subclass of string, because the wildcard extends string. You can also set a lower bound on a wildcard by using the super keyword in syntax, as seen in this example. In this case, the compiler will allow the passed in type to be an instance of string or a super class of string. Generic wild cards and wildcard bounding are probably the most complex aspect of generics in Java. If you're comfortable looking at syntax, using the question mark and the bounds extends and super in methods and other code declared, you have a really good grasp with Java generics.

Demo: Autoboxing and Collections
The next feature I want to talk about is called autoboxing and unboxing. It's not necessarily a generic‑specific topic, but it's used often with collections, and can be used with generic typing. We've also already seen this concept in action in some of our previous demos. I just haven't really pointed out exactly what is happening. I'm going to jump back to the map main demo class that we used when working with maps. I'm going to come down to about halfway where we were doing some demo code with tree maps and maps. You'll notice here that we declare a tree map with planets in it. The tree map is mapping the position from the sun to that particular planet. So in the case of this tree map, the tree map's key value is of type Integer, as seen up here on the declaration, and its value is of type String. Then down where we put the planets, it's using an int of 3 with a string value. Remember that Java is a typed language, and it's very strict on its typing. A primitive int is not the same as the integer Wrapper class. So how does this code compile, since we require that the generic type to be an integer? This is where autoboxing and unboxing comes into play. The Java Compiler can take a primitive type and turn it into its wrapper class equivalent and turn it back into its primitive type automatically for you. If we didn't have autoboxing, we would have to change our code to look something like this. This code is valid and compiles, but it's certainly more verbose. Autoboxing and unboxing really make the code easier to read and still provides for the same functionality. Java provides a wrapper class for each primitive data type, like an int, long, char, etc. If you pass in a primitive type where a wrapper class is needed, the Java Compiler will autobox that primitive into that wrapper class. And that's really all that's going to be required for you on the exam using Generics and autoboxing with regard to collections and other coding examples.

Summary
Generics provides a lot of flexibility and creates consistent code when you're using Java. Because Java is a typed and compiled language, generics really allow you to fine tune the parameters and arguments in your code. Remember that Java has set up some standard naming conventions, T for Types, E for Elements, K for Keys, and so on. Java allows you to set up one or more generic types associated with your class, using the diamond syntax. You can also apply generics to method parameters and return types, and generics syntax also supports wildcard typing and scoping or bounding your allowable class types in generic slots using the extends or super keywords. Finally, collections and any other Java code that you will be working with can utilize autoboxing. This just means that the compiler can convert a primitive data type into its wrapper class or vice versa. This makes coding more convenient and easy to read. That's it for the generics overview. Once you understand what generics does, using them with your collection APIs and other code will become second nature. Watch out on the exam if a collection is declared with a certain type like a string and then they try to add, say, an integer. The compiler would throw a compilation error. Since you won't have an actual compiler on the exam, you yourself have to become that compiler and keep an eye out for mismatched types and other issues. I do have one more clip coming up next that is a final exam concept review.

Final Exam Review Concepts
We're at the end of this course, and we're just about wrapped up. I just wanted to take one more time to go over the exam concepts so that you can be prepared when you go to take your test. Hopefully at this point, after going over these concepts, this review should feel familiar, and you'll know the concepts easily as I discuss them. The exam will show code with basic primitive arrays and array lists. You should feel comfortable analyzing and following code flow in code examples given with these constructs. Next, you need to be familiar with the Collection API hierarchy and understand lists, sets, queues, and maps. Know what each type is used for and be familiar with their differences. You should be familiar with many of the convenience methods provided by the collection: list, set, queue, and map interfaces, and what each of those methods do. You'll also need to know the details in differences of comparable and comparator. These are the workhorses of comparing objects in Java. When you're sorting collections and arrays in Java, the comparable and comparator interfaces will kick in. Collections mostly work with Java object types, as such, autoboxing becomes important because we also want to use primitive types with collections as well. The Java compiler will autobox primitives to their appropriate wrapper object classes. And finally, you want to have a good, solid understanding of generics, mainly typing, the naming conventions, the diamond operator, wild cards, generic parameters, and so on. With that, we're at the end of the course that covers collections, primitive arrays, and generics. Best of luck to you if you decide to take the exam, and thank you for watching this course.